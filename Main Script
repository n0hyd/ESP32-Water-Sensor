#include <WiFi.h>
#include <ESP_Mail_Client.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <esp_sleep.h>

// WiFi credentials
const char* ssid = "JonesNetwork";
const char* password = "jonespassword";

// Gmail credentials
const char* smtpServer = "smtp.gmail.com";
const int smtpPort = 465;
const char* emailSenderAccount = "burkejones@gmail.com";
const char* emailSenderPassword = "ewf cahb srci yugf";

// Email recipient
const char* emailRecipient = "9139090608@txt.att.net";

// SMTP session object
SMTPSession smtp;

// GPIO settings
const int touchPin = T0;  // Touch pin (T0 corresponds to GPIO 4 on some boards)
const int threshold = 30; // Set this based on your calibration

// NTP settings
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 0, 60000); // Update time every minute for accuracy

// Uncomment this line to enable battery voltage measurement
// #define ENABLE_BATTERY_VOLTAGE

// Constants for battery voltage measurement
#ifdef ENABLE_BATTERY_VOLTAGE
  #define BATTERY_PIN 35  // Analog pin for battery voltage measurement
  const float R1 = 100.0;  // Resistor 1 value (in kΩ)
  const float R2 = 220.0;  // Resistor 2 value (in kΩ)
  const float ADC_MAX_VOLTAGE = 3.3;  // Max voltage for ESP32 ADC
  const int ADC_MAX_VALUE = 4095;  // Max ADC value for 12-bit ADC
#endif

void setup() {
  Serial.begin(115200);
  analogReadResolution(12);  // 12-bit ADC resolution (0-4095)

  // Initialize WiFi (but don't connect yet)
  WiFi.mode(WIFI_STA);

  // Set GPIO pin mode for powering the touch sensor
  pinMode(touchPin, INPUT); // Set as input for touch sensing

  // Configure touch pin as a wake-up source
  esp_sleep_enable_touchpad_wakeup();
  touchAttachInterrupt(touchPin, callback, threshold);

  // Schedule a wake-up at 12:00 PM daily (uncomment all lines to use this)
 // #ifdef USE_TIMER
 // uint64_t wakeupTime = getSecondsToMidday() * 1000000ULL; // Convert seconds to microseconds
 // esp_sleep_enable_timer_wakeup(wakeupTime);
//  #endif

  #ifdef USE_INTERVAL
  uint64_t interval = 5 * 60 * 1000000ULL; // 5 minutes in microseconds
  esp_sleep_enable_timer_wakeup(interval);
  #endif

  Serial.println("Going to sleep now");
  delay(1000);

  // Go to deep sleep
  esp_deep_sleep_start();
}

void loop() {
  // This code will run only when the ESP32 wakes up
  Serial.println("Waking up...");

  // Check if woken up by the timer (12:00 PM check) or interval
  if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER) {
    Serial.println("Timer wakeup detected");

    // Update time from NTP server
    WiFi.begin(ssid, password);
    bool connected = false;
    unsigned long startTime = millis();
    while (millis() - startTime < 60000 && WiFi.status() != WL_CONNECTED) {
      delay(1000);
      Serial.println("Connecting to WiFi...");
    }
    if (WiFi.status() == WL_CONNECTED) {
      connected = true;
      Serial.println("Connected to WiFi");
    } else {
      Serial.println("Failed to connect to WiFi within timeout");
    }

    if (connected) {
      timeClient.begin();
      timeClient.update();

      String currentTime = timeClient.getFormattedTime();
      String currentDate = timeClient.getFormattedDate(); // Example format: "2024-08-29"
      currentDate.replace("-", "/"); // Change format to MM/DD/YYYY

      Serial.print("Current Time: ");
      Serial.println(currentTime); // Example: "15:45:30"
      Serial.print("Current Date: ");
      Serial.println(currentDate); // Example: "08/29/2024"

      // If battery voltage is enabled, read and print it
      #ifdef ENABLE_BATTERY_VOLTAGE
      float batteryVoltage = readBatteryVoltage();
      Serial.print("Battery Voltage: ");
      Serial.println(batteryVoltage);
      #endif

      // Take the average touch reading
      int touchValue = getAverageTouchReading();
      Serial.print("Average touch value: ");
      Serial.println(touchValue);

      // If no water detected, send "just checking in" email
      if (touchValue >= threshold) {
        sendCheckinEmail(currentTime, currentDate, batteryVoltage);
      }

      WiFi.disconnect(true);
    }
  }

  // Check if woken up by touchpad
  if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TOUCHPAD) {
    Serial.println("Touchpad wake-up detected!");

    // Take the average touch reading
    int touchValue = getAverageTouchReading();
    Serial.print("Average touch value: ");
    Serial.println(touchValue);

    // Initialize WiFi and connect
    WiFi.begin(ssid, password);
    bool connected = false;
    unsigned long startTime = millis();
    while (millis() - startTime < 60000 && WiFi.status() != WL_CONNECTED) {
      delay(1000);
      Serial.println("Connecting to WiFi...");
    }
    if (WiFi.status() == WL_CONNECTED) {
      connected = true;
      Serial.println("Connected to WiFi");
    } else {
      Serial.println("Failed to connect to WiFi within timeout");
    }

    if (connected) {
      // Update time from NTP server
      timeClient.begin();
      timeClient.update();

      String currentTime = timeClient.getFormattedTime();
      String currentDate = timeClient.getFormattedDate(); // Example format: "2024-08-29"
      currentDate.replace("-", "/"); // Change format to MM/DD/YYYY

      Serial.print("Current Time: ");
      Serial.println(currentTime);
      Serial.print("Current Date: ");
      Serial.println(currentDate);

      // Send the alert email with time and date
      sendAlert(currentTime, currentDate);
    }

    WiFi.disconnect(true);
  }

  // Go back to sleep after processing
  Serial.println("Going back to sleep");
  delay(1000);
  esp_deep_sleep_start();
}

// Function to send water detected alert
void sendAlert(String time, String date) {
  smtp.setPriority("High");
  smtp.setSubject("Water Detected!");

  String message = "DANGER Water Detected!\nCheck basement ASAP!\n" + time + " on " + date;
  smtp.setMessage(message.c_str(), false);

  smtp.addRecipient(emailRecipient);

  if (!smtp.connect()) {
    Serial.println("Failed to connect to SMTP server");
    return;
  }

  if (!MailClient.sendMail(smtp)) {
    Serial.println("Error sending Email, " + smtp.errorReason());
  } else {
    Serial.println("Water detection email sent successfully!");
  }

  smtp.closeSession();
}

// Function to send check-in email
void sendCheckinEmail(String time, String date, float batteryVoltage) {
  smtp.setPriority("Normal");
  smtp.setSubject("NO water detected, just checking in");
  
  String message = "NO water detected, just checking in:\nTime: " + time + "\nDate: " + date;
  
  #ifdef ENABLE_BATTERY_VOLTAGE
  message += "\nBattery Voltage: " + String(batteryVoltage) + "V";
  #endif

  smtp.setMessage(message.c_str(), false);

  smtp.addRecipient(emailRecipient);

  if (!smtp.connect()) {
    Serial.println("Failed to connect to SMTP server");
    return;
  }

  if (!MailClient.sendMail(smtp)) {
    Serial.println("Error sending Email, " + smtp.errorReason());
  } else {
    Serial.println("Check-in email sent successfully!");
  }

  smtp.closeSession();
}

// Function to calculate seconds until next 12:00 PM
uint64_t getSecondsToMidday() {
  timeClient.update();
  int currentHour = timeClient.getHours();
  int currentMinute = timeClient.getMinutes();
  int currentSecond = timeClient.getSeconds();

  int secondsUntilMidday = (12 * 3600) - (currentHour * 3600 + currentMinute * 60 + currentSecond);
  if (secondsUntilMidday <= 0) {
    secondsUntilMidday += 86400; // Adjust for next day's midday
  }

  return secondsUntilMidday;
}

// Function to get the average touch reading
int getAverageTouchReading() {
  int sum = 0;
  for (int i = 0; i < 8; i++) {
    sum += touchRead(touchPin);
    delay(10);  // Small delay to avoid reading too fast
  }
  return sum / 8;
}

#ifdef ENABLE_BATTERY_VOLTAGE
// Function to read battery voltage
float readBatteryVoltage() {
  int analogValue = analogRead(BATTERY_PIN);
  float voltage = (analogValue * ADC_MAX_VOLTAGE) / ADC_MAX_VALUE;
  return voltage * ((R1 + R2) / R2); // Apply voltage divider formula
}
#endif


